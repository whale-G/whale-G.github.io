---
title: "二分查找算法"
date: 2025-10-10
categories: [知识分享]
tags: [数据结构&算法]
math: true
---

## 定义

**二分查找**（英语：binary search）[[a\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-11)是用于查找[有序数组](https://zh.wikipedia.org/wiki/有序数组)中目标值位置的[搜索算法](https://zh.wikipedia.org/wiki/搜索算法)。[[11\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-FOOTNOTECormenLeisersonRivestStein200939-12)[[2\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-FOOTNOTECormenLeisersonRivestStein201322-2)[[12\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-13)二分查找比较目标值与数组中间元素的大小，如果两者不相等，则会舍弃不可能包含目标值的那一半区间，然后在剩余区间重复此过程：每次选取新的中间元素并与目标值比较，直至找到目标或区间为空。若区间为空，则说明目标值不存在。

二分查找在[最坏情况](https://zh.wikipedia.org/w/index.php?title=最好、最坏、平均情况&action=edit&redlink=1)下的[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)为[对数级别](https://zh.wikipedia.org/wiki/对数时间)，即需做$O(logN)$次比较，其中`N`是数组元素的数量。[[b\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-14)[[13\]](https://zh.wikipedia.org/wiki/二分搜尋#cite_note-FloresMadpis1971-15)除规模较小的数组外，二分查找通常比[线性搜索](https://zh.wikipedia.org/wiki/线性搜索)更快。二分查找的搜索效率可能不及[哈希表](https://zh.wikipedia.org/wiki/哈希表)等[数据结构](https://zh.wikipedia.org/wiki/数据结构)，但其还可用于查找最接近目标值的上界或下界，即使目标值不在数组中。

## 实现方式

### 方式一：查找区间为左闭右闭

即每次迭代时进行查找的区间为左闭右闭，包含左右两侧边界元素，举例`[1,1]`。

> 代码实现（c++）
>
> 在一个升序的整型数组`nums`中查找目标值`target`。如果`target`存在则返回下标，否则返回`-1`。

```c++
int binarySearch(vector<int>& nums, int target) {
    int light = 0, right = nums.size()-1, mid = 0;
    // 此处while循坏条件须符合左闭右闭区间，故为'<='
    while(light <= right) {
        mid = light + (right - light) / 2;
        // 当target在区间的右侧时，修改左边界。
        if(target > nums[mid])
            // 此时nums[mid]已经参与比较，故新的左边界需要`mid+1`
            light = mid + 1;
        // 当target在区间左侧时，同理。
        else if(target < nums[mid])
            right = mid - 1;
        else
            return mid;
    }
    return -1;
}
```



### 方式二：查找区间为左闭右开

即每次迭代时进行查找的区间为左闭右开，仅包含左侧边界元素，举例`[1,1)`。

> 代码实现（c++）

```c++
int binarySearch(vector<int>& nums, int target) {
    // 需要注意：有边界初始化为数组尾元素后一个位置。
    int light = 0, right = nums.size(), mid = 0;
    // 此处while循坏条件须符合左闭右开区间，故为'<'
    while(light <= right) {
        mid = light + (right - light) / 2;
        // 当target在区间的右侧时，同方式一。
        if(target > nums[mid])
            light = mid + 1;
        // 当target在区间左侧时，nums[mid]不在区间中。
        else if(target < nums[mid])
            // 故新的右边界可直接取mid
            right = mid;
        else
            return mid;
    }
    return -1;
}
```



## 练习

[力扣No.704](https://leetcode.cn/problems/binary-search/description/)

